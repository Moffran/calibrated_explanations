# v0.11.0 Release Task Implementation Plan

This plan expands the v0.11.0 tasks from `docs/improvement/RELEASE_PLAN_v1.md`
with implementation details grounded in ADRs, engineering standards, and the
current code layout. Each section lists concrete work items, impacted modules,
verification steps, and open questions needed to satisfy the release gate.

v0.11.0 is an **ADR gap closure milestone**. The authoritative task list is the
"v0.11.0 (domain model & preprocessing finalisation)" section in
`docs/improvement/RELEASE_PLAN_v1.md`.

## Source references reviewed

- Release task list + appendix references: `docs/improvement/RELEASE_PLAN_v1.md`.
- ADRs: all files in `docs/improvement/adrs/` (including superseded ADRs).
  - Primary drivers for v0.11.0 are ADR-004/005/008/009/010/012/020/026/027/028/030/031.
- Standards: all files in `docs/standards/` (STD-001..STD-005).
- Standard-001 execution roadmap: `docs/improvement/Standard-001_nomenclature_remediation.md`.
- Test standards and enforcement guidance:
  - `.github/tests-guidance.md` (authoritative test-writing rubric)
  - `docs/standards/STD-003-test-coverage-standard.md`
  - `docs/improvement/ANTI_PATTERN_REMEDIATION_PLAN.md`
- Existing tooling/scripts referenced by release tasks:
  - `scripts/audit_notebook_api.py` (ADR-020)
  - `scripts/detect_test_anti_patterns.py` (ADR-030)
  - `scripts/snapshot_public_api.py` (API surface snapshot)
  - `.github/private_member_allowlist.json` (Pattern 1 remediation)

---

## Release tasks covered (from `RELEASE_PLAN_v1.md`)

The v0.11.0 milestone contains 16 tasks. This plan has matching sections for
each of them, in order.

---

## Global rules (deterministic reproducibility + security)

These rules apply across all v0.11.0 work items (domain model, preprocessing,
serialization, persistence, plugin telemetry).

1. **Canonical hashing of manifests.**
      - Any manifest used for artifact identity or reproducibility MUST be
         canonicalized deterministically and hashed as:

         ```py
         canonical = json.dumps(
               manifest,
               sort_keys=True,
               separators=(",", ":"),
               ensure_ascii=False,
         ).encode("utf-8")
         parameters_hash = "sha256:" + sha256(canonical).hexdigest()
         ```

      - Manifests MUST NOT include raw training data or PII. If sensitive keys are
         detected, raise `ValidationError`.
      - Persist the canonical manifest as an immutable artifact and, where
         permitted, reference it from `metadata.audit.config_artifact` (or
         `metadata.audit.run_id` when artifact storage is unavailable).

2. **Artifact manifest schema.**
      - All persisted artifacts (parameter manifest, calibrator primitives,
         mappings, saved state) MUST include:
         - `schema_version`
         - `tool_name` or `component_id`
         - `created_by`
         - `created_at`
         - `checksums` (file → `sha256:<hex>`)
      - `save_state()` MUST write a top-level manifest and the files listed
         therein.
      - `load_state()` MUST validate checksums and `schema_version` before
         rehydration.

3. **No opaque blobs by default.**
      - Default persistence/export APIs MUST be JSON-safe and portable.
      - Opaque binary exports (e.g., pickle) are allowed only behind an explicit
         opt-in API and MUST be documented as non-portable / potentially insecure.
      - Provide an advanced plugin hook for tightly controlled binary exchange,
         but keep it non-default.

---

## 1) ADR-008: Domain model authority (Explanation/FeatureRule)

**Goal:** Make the ADR-008 domain model authoritative in runtime flows (not just
as an adapter), fix legacy round-trips, enrich calibration/model metadata, add
golden fixtures, and harden `_safe_pick`.

### 1.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/improvement/adrs/ADR-008-explanation-domain-model-and-compat.md](docs/improvement/adrs/ADR-008-explanation-domain-model-and-compat.md)** — authoritative domain model and compatibility rules.
- [docs/improvement/adrs/ADR-005-explanation-json-schema-versioning.md](docs/improvement/adrs/ADR-005-explanation-json-schema-versioning.md) — schema v1 contract, additive evolution rules, provenance/metadata extension surface.
- [docs/improvement/adrs/ADR-002-validation-and-exception-design.md](docs/improvement/adrs/ADR-002-validation-and-exception-design.md) — validation expectations and exception taxonomy.
- [docs/standards/STD-003-test-coverage-standard.md](docs/standards/STD-003-test-coverage-standard.md) — fixture/testing expectations.
- [.github/tests-guidance.md](.github/tests-guidance.md) — test-writing rubric.

### 1.1 Current anchors in code

- Domain model: `src/calibrated_explanations/explanations/models.py`.
- Legacy collection implementation: `src/calibrated_explanations/explanations/explanations.py`.
- Serialization helpers: `src/calibrated_explanations/serialization.py`.

### 1.2 Key gaps to close (from release plan wording)

- Runtime flows still primarily operate on legacy dicts/lists, not domain objects.
- Legacy → domain → legacy round-trips are not guaranteed.
- Missing structured metadata (calibration/model provenance) on the domain object.
- `_safe_pick` in `from_legacy_dict` is tolerant but not robust/deterministic.
- Golden fixtures for domain-model parity are missing.

### 1.3 Implementation steps

1. **Enforce the conversion boundary.**
      - The canonical conversion boundary is **immediately after any legacy
         explanation dict is produced**.
      - Add a `convert_legacy_to_domain(legacy_dict)` helper and require all call
         sites to call it at the production point.
      - From that point onward, the **domain model is authoritative**. Legacy
         dicts must not be mutated downstream (scoring, aggregation,
         post-processing, telemetry, serialization).
      - Add a lightweight lint/CI check (or debug-only assertion) that flags code
         paths which mutate legacy dicts instead of domain objects after the
         boundary.

2. **Fix round-trips and support conjunctive rules.**
      - Audit `from_legacy_dict(...)` in `explanations/models.py` and define the
         minimum supported legacy keys.
      - Support conjunctive rules as an additive JSON v1 minor:
         `rules[*].feature: integer | array[integer]`.
      - Domain model behavior:
         - Normalize `FeatureRule.feature` to `List[int]` for internal logic
            (singletons become length-1 lists).
         - Expose an `is_conjunctive` boolean (or equivalent) for clarity.
      - Serialization behavior:
         - Emit `feature` as an integer for single-feature rules and an array for
            conjunctive rules (avoid unnecessary churn for scalar-only consumers).
      - Add fixtures and round-trip tests for factual, alternative, and
         conjunctive cases.

3. **Replace `_safe_pick` with deterministic parsing.**
      - Replace the current heuristic fallback with `deterministic_pick(container,
         idx_or_key=None)`.
      - Deterministic behavior (no silent fallbacks):
         - `None` containers raise `ValidationError`.
         - mappings return the requested key (or `'predict'` when no key provided),
            else raise `ValidationError`.
         - sequences return `container[idx]` (validated) or `container[0]` when no
            index is provided; empty sequences raise `ValidationError`.
         - scalars return the scalar when `idx` is `None` or `0`, else raise.
      - Do not mask `TypeError`; raise `ValidationError` per ADR-002.
      - Replace all uses of the old `_safe_pick` and add unit tests covering:
         scalars, mappings, sequences, empty sequences, invalid index/key types.

4. **Attach runtime parameters and minimal default provenance.**
      - Add a typed `Explanation.runtime_parameters` (or
         `Explanation.calculation_context`) as the **authoritative** location for
         behaviour-changing parameters (thresholds, bins, conditionals,
         preprocessing map pointer, calibration pointer).
      - Compute and store a canonical parameter manifest and record
         `provenance.parameters_hash = "sha256:<hex>"` where `<hex>` is the sha256
         of the canonicalized manifest bytes.
      - Canonicalization and hashing MUST follow the global rules above.
      - The parameter manifest artifact MUST include the global artifact fields
         (`schema_version`, provenance fields, and `checksums`).
      - Persist the canonical manifest as an immutable artifact keyed by the hash
         and (where permitted) record a pointer in `metadata.audit.config_artifact`
         (or `metadata.audit.run_id`).
      - Populate these default fields unless caller explicitly supplies values or
         policy prohibits:
         - `provenance.library_version` (literal library version string)
         - `provenance.calibration_version` (artifact content id if available,
            else `null`)
         - `provenance.parameters_hash` (required when runtime parameters are
            material)
      - Ensure `provenance` and `metadata` remain **non-authoritative** for
         computation; they identify state, they do not change interpretation.
      - Do not write raw training data or PII into manifests or public payload
         fields.

5. **Golden fixtures and acceptance-focused tests.**
      - Add golden fixtures for:
         - factual explanation
         - alternative explanation
         - conjunctive rule case
      - Add round-trip tests for legacy↔domain↔JSON parity.
      - Add parameter-hash verification tests that fetch a manifest (fixture or
         fake artifact store) and re-hash it to confirm equality with
         `provenance.parameters_hash`.

### 1.4 Decisions (v0.11.0)

- **Conversion boundary:** Convert legacy dicts → domain objects immediately
   after legacy explanation dict production; domain model is authoritative.
- **Parameters & reproducibility:** Attach authoritative
   `runtime_parameters`/`calculation_context` to the domain model and record a
   canonical `provenance.parameters_hash` computed as sha256 of a canonical
   manifest; persist the manifest as an immutable artifact and reference it from
   `metadata.audit` where permitted.
- **Provenance defaults:** Populate minimal, non-sensitive defaults:
   `library_version`, `calibration_version` (if available), `parameters_hash`.
- **Conjunctive rules:** Support `rules[*].feature: integer | array[integer]`
   as an additive JSON v1 minor; normalize domain `feature` to `List[int]` and
   expose `is_conjunctive`.
- **Parsing hardening:** Replace `_safe_pick` with `deterministic_pick` and raise
   `ValidationError` on structural incompatibility; no `arr[-1]` fallbacks.

### 1.5 Verification checklist

- Conversion boundary enforced (tests and/or CI check confirm early conversion;
   downstream code does not mutate legacy dicts).
- Golden fixtures exist for factual, alternative, and conjunctive rule cases.
- Round-trip parity tests pass for legacy↔domain↔JSON.
- JSON v1 schema and serialization support `feature` as int or array[int].
- `provenance.parameters_hash` is populated (when required) and hash
   verification tests re-hash the canonical manifest and assert equality.
- Canonical manifests are rejected (as `ValidationError`) when they contain
  sensitive keys.
- `deterministic_pick` tests cover scalars, dicts, sequences, empty sequences,
   and invalid cases; failures raise `ValidationError` per ADR-002.
- Run the test suite: `pytest -q`.

---

## 2) ADR-009: Preprocessing automation + mapping persistence

**Goal:** Complete preprocessing automation with `auto_encode='auto'`, enforce
unseen-category policy, provide mapping export/import helpers, improve dtype
diagnostics, and align telemetry/docs.

### 2.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/improvement/adrs/ADR-009-input-preprocessing-and-mapping-policy.md](docs/improvement/adrs/ADR-009-input-preprocessing-and-mapping-policy.md)** — preprocessing automation requirements and JSON-safe mapping persistence contract.
- [docs/improvement/adrs/ADR-002-validation-and-exception-design.md](docs/improvement/adrs/ADR-002-validation-and-exception-design.md) — validation error expectations for dtype/unseen-category failures.
- [docs/improvement/adrs/ADR-031-calibrator-serialization-and-state-persistence.md](docs/improvement/adrs/ADR-031-calibrator-serialization-and-state-persistence.md) — persistence patterns that may need to include mapping snapshots.
- [docs/standards/STD-003-test-coverage-standard.md](docs/standards/STD-003-test-coverage-standard.md) — required test coverage and determinism.
- [.github/tests-guidance.md](.github/tests-guidance.md) — test-writing rubric.

### 2.1 Current anchors in code

- Wrapper: `src/calibrated_explanations/core/wrap_explainer.py`.
- Config: `src/calibrated_explanations/api/config.py` (`auto_encode`, `unseen_category_policy`).
- Preprocessor metadata snapshot utilities already exist:
  - `WrapCalibratedExplainer.get_preprocessor_metadata()`
  - `WrapCalibratedExplainer.set_preprocessor_metadata()`

### 2.2 Key gaps (from ADR-009 status + release plan)

- `auto_encode='auto'` does not yet activate a built-in encoder deterministically.
- Mapping export/import contract (JSON-safe primitives) is not available.
- Unseen-category policy must be enforced consistently in inference.
- Dtype diagnostics for DataFrames/non-numeric inputs must be actionable.

### 2.3 Implementation steps

1. **Define and publish the mapping snapshot protocol.**
      - Add `HasMappingSnapshot` protocol in
         `src/calibrated_explanations/preprocessing/protocols.py`:

         ```py
         class HasMappingSnapshot(Protocol):
               schema_version: str
               def get_mapping_snapshot(self) -> Dict[str, Any]: ...
               def load_mapping_snapshot(self, snapshot: Dict[str, Any]) -> None: ...
         ```

      - Snapshot requirements:
         - JSON-safe primitives only.
         - Includes: `schema_version`, `preprocessor_type`, `stable_seed`,
            `column_order`, per-column category order, and a per-column
            `encoding_spec`.
      - Document versioning: additive changes only; break only on major.

2. **Implement a deterministic built-in encoder.**
      - Implement a built-in encoder with `fit_transform` / `transform`,
         `get_mapping_snapshot()` and `load_mapping_snapshot()`.
      - Determinism rules:
         - stable seed (`stable_seed`) is recorded in metadata,
         - deterministic category ordering (alphabetical/numeric),
         - stable column ordering.
      - Enforce `unseen_category_policy` at transform time; default remains
         `"error"`. Provide explicit behavior for `"ignore"`.

3. **Activate `auto_encode='auto'` in fit paths.**
    - In `wrap_explainer.py`, extend `_pre_fit_preprocess()`:
       - if user provided a preprocessor: use it (existing behavior).
       - else if `auto_encode` resolves to `"auto"`: build+fit the built-in encoder.
       - else: no preprocessing.
    - Ensure the result is deterministic across runs (seeded, stable category ordering).

4. **Implement mapping export/import helpers (protocol-based).**
      - Add public wrapper-layer methods consistent with ADR-009:
         - `WrapCalibratedExplainer.export_mapping() -> dict`
         - `WrapCalibratedExplainer.import_mapping(mapping: dict) -> None`
      - Export rules:
         - If `_preprocessor` implements `HasMappingSnapshot`, return the snapshot
            plus `schema_version` and a deterministic `mapping_hash`.
         - If `_preprocessor` does not implement the protocol, raise
            `MappingExportNotSupportedError` with actionable guidance.
      - Import rules:
         - Accept only JSON-safe snapshots conforming to the protocol.
         - Reject opaque blobs by default.
         - Validate `schema_version` and `mapping_hash` (where present).
      - Ensure mapping artifacts align with the global artifact manifest rules.

5. **Advanced extension (explicit opt-in).**
      - Provide an opt-in plugin hook (e.g.,
         `register_mapping_serializer(name, serializer)`) to enable controlled
         binary exchange for specialized tooling.
      - Keep this non-default and document portability/security implications.

6. **Improve dtype diagnostics.**
    - Identify where the library currently fails on non-numeric input and ensure
       the raised error includes:
       - offending column(s),
       - suggested fix (`auto_encode='auto'` or user preprocessor),
       - policy note about unseen categories.

7. **Telemetry/doc alignment.**
    - Ensure `WrapCalibratedExplainer._build_preprocessor_metadata()` is emitted
       consistently, and docs mention the meaning of `mapping_snapshot`.

### 2.4 Decision (v0.11.0)

- Adopt a small public protocol (`HasMappingSnapshot`) for mapping export/import.
- Built-in encoder implements the protocol.
- User preprocessors participate only by implementing the protocol; otherwise
   export/import raises `MappingExportNotSupportedError`.
- Opaque blob export/import is disallowed by default; a separate opt-in hook is
  available for advanced tooling.

### 2.5 Verification checklist

- Unit tests:
  - `auto_encode='auto'` produces identical transformed feature layout across
    fit+predict in the same run.
  - `export_mapping()` + `import_mapping()` reproduces identical predictions.
   - Built-in encoder is deterministic across runs given the same `stable_seed`.
  - unseen-category policy:
    - default `"error"` fails on unseen category,
    - `"ignore"` does not fail and produces deterministic output.
   - Export/import for a user preprocessor that does not implement
      `HasMappingSnapshot` raises `MappingExportNotSupportedError` with clear
      guidance.
- Run `pytest -q`.

---

## 3) ADR-030: Test quality tooling upgrades (determinism + assertions)

**Goal:** Upgrade test-quality tooling and wire it into CI.

### 3.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/improvement/adrs/ADR-030-test-quality-priorities-and-enforcement.md](docs/improvement/adrs/ADR-030-test-quality-priorities-and-enforcement.md)** — enforcement posture and incremental rollout expectations.
- [docs/improvement/ANTI_PATTERN_REMEDIATION_PLAN.md](docs/improvement/ANTI_PATTERN_REMEDIATION_PLAN.md) — existing anti-pattern taxonomy and remediation context.
- **[docs/standards/STD-003-test-coverage-standard.md](docs/standards/STD-003-test-coverage-standard.md)** — baseline quality/coverage expectations.
- **[.github/tests-guidance.md](.github/tests-guidance.md)** — authoritative test-writing rubric used by the detector.

### 3.1 Current anchors in repo

- Anti-pattern scanner entrypoint: `scripts/detect_test_anti_patterns.py`.
- Scanner implementation: `scripts/anti-pattern-analysis/detect_test_anti_patterns.py`.
- Authoritative guidance: `.github/tests-guidance.md`.

### 3.2 Key gaps (from ADR-030 + release plan)

- Existing detector focuses on a small set of patterns; v0.11.0 requires
   assertion and determinism checks.

### 3.3 Implementation steps

1. **Extend the anti-pattern detector.**
    - Add new findings for:
       - tests without assertions (treat `pytest.raises` and `pytest.warns` as assertions),
       - use of `random.*` without explicit seeding,
       - use of time/network primitives without patching.
    - Keep the detector behavior-first: avoid brittle AST rules that false
       positive heavily.

2. **Add a CI enforcement mode.**
    - Introduce a `--check` mode (or equivalent) that returns non-zero when
       violations exist.
      - Decision (v0.11.0): enforce **no new violations** using a committed
         baseline file.
      - Add flags:
         - `--check` (CI mode): exit non-zero on new violations
         - `--report <path>`: write full report
         - `--rebaseline`: regenerate baseline locally (PR-reviewed)

3. **Wire into CI.**
    - Add the script to the core CI workflow so that it runs alongside tests.
    - Ensure it does not require heavy optional dependencies.
      - Commit a baseline file (e.g., `.github/test-quality-baseline.json`) and
         make CI compare findings against it.
      - Publish the report as a CI artifact.

### 3.4 Decision (v0.11.0)

- Enforce “no new violations” immediately using a committed baseline file.
- Baseline updates happen via `--rebaseline` and must be PR-reviewed.

### 3.5 Verification checklist

- Running `python scripts/detect_test_anti_patterns.py` generates a report.
- Running the new check mode fails when violations exist.
- CI fails on *new* violations compared to baseline, but allows existing
   baseline entries.
- CI shows the detector as a distinct step with actionable output.

---

## 4) ADR-031: Calibrator primitives + explainer state persistence

**Goal:** Implement versioned `to_primitive`/`from_primitive` contracts for
calibrators and add explainer `save_state()`/`load_state()`.

### 4.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/improvement/adrs/ADR-031-calibrator-serialization-and-state-persistence.md](docs/improvement/adrs/ADR-031-calibrator-serialization-and-state-persistence.md)** — serialization/persistence contract and versioning expectations.
- [docs/improvement/adrs/ADR-009-input-preprocessing-and-mapping-policy.md](docs/improvement/adrs/ADR-009-input-preprocessing-and-mapping-policy.md) — mapping snapshots that should round-trip through persistence.
- [docs/improvement/adrs/ADR-005-explanation-json-schema-versioning.md](docs/improvement/adrs/ADR-005-explanation-json-schema-versioning.md) — versioning principles and JSON-safe constraints.
- [docs/improvement/adrs/ADR-002-validation-and-exception-design.md](docs/improvement/adrs/ADR-002-validation-and-exception-design.md) — failure modes and exception types.
- [docs/standards/STD-003-test-coverage-standard.md](docs/standards/STD-003-test-coverage-standard.md) — persistence round-trip testing expectations.

### 4.1 Current anchors in code

- Calibration modules live under `src/calibrated_explanations/core/` and
   `src/calibrated_explanations/calibration/`.
- Export/import is already a public-facing theme in docs (see foundations).

### 4.2 Implementation steps

1. **Define primitive schema and version policy.**
    - Use JSON-safe primitives only.
    - Require `schema_version` and a calibrator type discriminator.
      - Every calibrator primitive includes: `schema_version`, `calibrator_type`,
         `parameters`, and `checksums`.
      - Validate `schema_version` and fail with actionable errors when unsupported.

2. **Implement calibrator primitives.**
    - For each built-in calibrator, add:
       - `to_primitive() -> dict`
       - `from_primitive(payload: Mapping[str, object]) -> <Calibrator>`
    - Validate schema version range and fail fast with actionable errors.

3. **Implement explainer persistence API.**
    - Add `save_state(path_or_fileobj)` and `load_state(path_or_fileobj)` on the
       wrapper entry point (recommended) so preprocessing (ADR-009) is included.
      - Persist as a directory or archive containing:
         - `manifest.json` (top-level manifest with checksums and schema version)
         - calibrator primitive JSON
         - preprocessing mapping snapshot(s)
         - `explainer_config.json` (plugin identifiers and versions)
         - optional `audit.log`
      - Implement `load_state()` to validate checksums and `schema_version` before
         rehydrating; on mismatch raise `IncompatibleStateError`.

4. **Round-trip tests.**
    - Ensure saved state rehydrates to identical predictions on the same input.
    - Ensure incompatible schema versions raise a documented exception.
      - Add a negative test that mutates a checksum and asserts `load_state()`
         rejects the artifact.

### 4.3 Verification checklist

- Unit tests cover save/load for both classification and regression flows.
- State artifacts are JSON-safe and stable.
- Run `pytest -q`.

---

## 5) ADR-005: Strict payload validator + fixture coverage

**Goal:** Close payload validation gaps by ensuring schema validation and
semantic invariants are reliably enforced, and add fixture coverage.

### 5.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/improvement/adrs/ADR-005-explanation-json-schema-versioning.md](docs/improvement/adrs/ADR-005-explanation-json-schema-versioning.md)** — schema versioning and strictness expectations.
- [docs/improvement/adrs/ADR-002-validation-and-exception-design.md](docs/improvement/adrs/ADR-002-validation-and-exception-design.md) — validation/exception expectations.
- [docs/improvement/adrs/ADR-008-explanation-domain-model-and-compat.md](docs/improvement/adrs/ADR-008-explanation-domain-model-and-compat.md) — domain model ↔ serialization compatibility requirements.
- **[docs/standards/STD-003-test-coverage-standard.md](docs/standards/STD-003-test-coverage-standard.md)** — fixture coverage requirements.

### 5.1 Current anchors in code

- JSON schema: `src/calibrated_explanations/schemas/explanation_schema_v1.json`.
- Schema helper: `src/calibrated_explanations/schema/validation.py`.
- Serialization invariants: `src/calibrated_explanations/serialization.py`.

### 5.2 Key gaps (from release plan wording)

- Schema validation is optional when `jsonschema` is not installed.
- Schema currently enforces `explanation_type` ∈ {factual, alternative}; ensure
   this matches runtime behavior and fixtures.
- Fixture coverage needs to exercise schema and invariants.

### 5.3 Implementation steps

1. **Make validation strict (without forcing heavy deps).**
    - Keep `jsonschema` optional, but add a minimal built-in validator that
       checks:
       - required keys,
       - allowed `explanation_type`,
       - `rules[*].feature` shape,
       - payload-level types for core fields.
    - When `jsonschema` is available, run full schema validation.

2. **Align schema with runtime rule shapes.**
    - If conjunctive rules are to be supported in JSON, update schema to allow
       `feature` as `integer | array[integer]` (additive).
    - Otherwise, explicitly reject conjunctive rules in serialization with a
       clear error and document the limitation.

3. **Add fixtures + tests.**
    - Add valid/invalid payload fixtures.
    - Tests must assert failures are raised (not silently skipped).

### 5.4 Verification checklist

- `serialization.to_json()` fails fast on invalid payloads even without
   `jsonschema` installed.
- `schema.validate_payload()` provides full-schema enforcement when `jsonschema`
   is installed.
- Tests cover both modes.

---

## 6) ADR-012: Notebook/gallery execution + time ceilings

**Goal:** Document the tooling choice and enforce notebook execution/time
ceilings in docs CI.

### 6.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/improvement/adrs/ADR-012-documentation-and-gallery-build-policy.md](docs/improvement/adrs/ADR-012-documentation-and-gallery-build-policy.md)** — notebook/gallery execution policy and time ceilings.
- [docs/improvement/adrs/ADR-010-core-vs-evaluation-split-and-distribution.md](docs/improvement/adrs/ADR-010-core-vs-evaluation-split-and-distribution.md) — keeps heavy/optional deps out of core installs.
- [docs/standards/STD-004-documentation-audience-standard.md](docs/standards/STD-004-documentation-audience-standard.md) — doc structure and audience expectations.

### 6.1 Implementation steps

1. **Execution engine (`nbconvert` MVP).**
      - Use `nbconvert` invoked from docs CI to execute notebooks.
      - Wrap execution in a stable driver script that:
         - sets per-notebook and per-cell timeouts via env vars
            (`DOCS_NOTEBOOK_TIMEOUT_SECS`, `DOCS_CELL_TIMEOUT_SECS`),
         - captures execution output,
         - emits a JSON execution report (success/failure, timing, cell-level logs).
      - Document a migration path to `sphinx-gallery` in a later release.

2. **Enforce time ceilings.**
    - Configure per-notebook and/or per-cell timeouts.
    - Ensure failures are blocking on release branches per ADR-012.
      - Document how to mark long-running examples as offline/manual and skipped
         in CI.

3. **Make optional dependencies explicit.**
    - Ensure docs execution jobs install the right extras (viz/notebooks).
    - Ensure core unit tests do not require these extras (ADR-010).

### 6.2 Decision (v0.11.0)

- Use `nbconvert` as the MVP execution engine with explicit timeouts.
- Document a later migration path to `sphinx-gallery`.

### 6.3 Verification checklist

- Docs CI runs notebook execution with explicit timeouts.
- A deliberately failing example causes the docs job to fail.
- A smoke test covers the notebook execution driver behavior.

---

## 7) ADR-020: Legacy API stability gates (checklist + audit workflow)

**Goal:** Add a release checklist hook and an audit workflow for notebooks/API.

### 7.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/improvement/adrs/ADR-020-legacy-user-api-stability.md](docs/improvement/adrs/ADR-020-legacy-user-api-stability.md)** — legacy stability policy and expected audit workflow.
- **[docs/improvement/legacy_user_api_contract.md](docs/improvement/legacy_user_api_contract.md)** — authoritative list of allowed/legacy user-facing APIs.
- [docs/improvement/adrs/ADR-012-documentation-and-gallery-build-policy.md](docs/improvement/adrs/ADR-012-documentation-and-gallery-build-policy.md) — release-branch gating expectations (docs as a gate).
- [.github/pull_request_template.md](.github/pull_request_template.md) — checklist integration point.

### 7.1 Current anchors in repo

- Notebook audit script: `scripts/audit_notebook_api.py`.
- API snapshot script: `scripts/snapshot_public_api.py`.
- PR template exists: `.github/pull_request_template.md`.

### 7.2 Implementation steps

1. **Define the “release checklist” artifact.**
      - Create `docs/improvement/release_checklist.md`.
      - Add explicit checklist items:
         - legacy contract touched? (yes/no)
         - notebooks audited? (yes/no)
         - API snapshot updated? (if required)
      - Reference the checklist from `.github/pull_request_template.md`.

2. **Make notebook audit actionable.**
    - Update `scripts/audit_notebook_api.py` so it can run in a strict mode:
       - fail when unknown API calls are detected,
       - emit a JSON report artifact.
    - Align the method allowlists with `docs/improvement/legacy_user_api_contract.md`.
      - Add output guidance: `--json` writes a stable report artifact path (e.g.,
         `artifacts/audit_notebook_api_<ref>.json`).

3. **Wire audit into CI.**
    - Add a CI step that runs the notebook audit in report mode (mainline) and
       strict mode (release branch), consistent with ADR-012 release-branch gates.

### 7.3 Verification checklist

- Running `python scripts/audit_notebook_api.py notebooks --json` produces a
  report.
- Running strict mode fails on unknown methods.

---

## 8) ADR-026: Plugin semantics hardening (invariants + immutability + telemetry)

**Goal:** Enforce strict invariants and immutability, and ensure telemetry
completeness for explanation plugin execution.

### 8.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/improvement/adrs/ADR-026-explanation-plugin-semantics.md](docs/improvement/adrs/ADR-026-explanation-plugin-semantics.md)** — plugin invariants, immutability expectations, and telemetry requirements.
- [docs/improvement/adrs/ADR-002-validation-and-exception-design.md](docs/improvement/adrs/ADR-002-validation-and-exception-design.md) — exception types for invariant violations.
- [docs/improvement/adrs/ADR-028-logging-and-governance-observability.md](docs/improvement/adrs/ADR-028-logging-and-governance-observability.md) — governance logging/telemetry expectations.
- [docs/standards/STD-005-logging-and-observability-standard.md](docs/standards/STD-005-logging-and-observability-standard.md) — logging expectations for telemetry.
- [docs/standards/STD-003-test-coverage-standard.md](docs/standards/STD-003-test-coverage-standard.md) — tests for “bad plugin” invariants.

### 8.1 Current anchors in code

- Prediction bridge + monitor is described in ADR-026 and implemented in core.
- Feature filter and orchestrator already attach logging context.

### 8.2 Implementation steps

1. **Immutability enforcement.**
      - Pass immutable contexts to plugins (frozen dataclasses and
         `types.MappingProxyType` for dict-like payloads).
      - At plugin boundary, perform a shallow immutability check and capture a
         copy for telemetry.
      - If a plugin attempts to mutate the provided context, raise
         `ConfigurationError` including the plugin id.

2. **Invariant enforcement.**
      - Ensure invariants are enforced for plugin outputs, not only for
         serialization:
         - `low <= predict <= high` for all intervals
         - required calibrated bridge call occurs per invocation
      - Fail as `PluginInvariantError` (subclass of `ConfigurationError`) and
         include `plugin_id`, `call_id`, and the failing invariant message.

3. **Telemetry completeness.**
      - Per-invocation telemetry must include:
         - `plugin_id`, `plugin_version`
         - `invocation_id` (UUID)
         - `start_ts`, `end_ts`
         - `input_hash`, `output_hash` (sha256 of canonicalized JSON)
         - `invariant_status` (pass/fail)
      - Ensure governance logger uses `calibrated_explanations.governance.*` and
         telemetry sinks are configurable.

### 8.3 Verification checklist

- Unit tests include a minimal “bad plugin” that violates invariants and
   asserts the correct exception type and message.
- Tests assert that telemetry is emitted for failure cases.

---

## 9) ADR-004 naming drift + ADR-010 core-only dependency clarity

**Goal:** Resolve naming drift around the parallel facade and verify that
core-only installs do not require matplotlib at import time.

### 9.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/improvement/adrs/ADR-004-parallel-backend-abstraction.md](docs/improvement/adrs/ADR-004-parallel-backend-abstraction.md)** — parallel facade naming and abstraction intent.
- **[docs/improvement/adrs/ADR-010-core-vs-evaluation-split-and-distribution.md](docs/improvement/adrs/ADR-010-core-vs-evaluation-split-and-distribution.md)** — core-only import constraints and optional dependency policy.
- [docs/standards/STD-001-nomenclature-standardization.md](docs/standards/STD-001-nomenclature-standardization.md) — naming conventions to apply when resolving drift.

### 9.1 Current anchors in code

- Parallel abstraction: `src/calibrated_explanations/parallel/parallel.py` defines `ParallelExecutor`.
- ADR-004 text uses “ParallelFacade”; release plan calls out drift.

### 9.2 Implementation steps

1. **Resolve naming drift (choose one approach).**
      - Decision (v0.11.0):
         - Keep `ParallelExecutor` as the canonical implementation name.
         - Add `ParallelFacade = ParallelExecutor` as a stable alias.
         - Add a short ADR-004 addendum recording canonical naming + alias.
      - Add a unit test ensuring `ParallelFacade is ParallelExecutor` and that
         importing either name works.
      - Note the alias in the release notes / `CHANGELOG.md`.

2. **Core-only import verification.**
    - Add a CI job that installs without `[viz]` and runs:
       - `python -c "import calibrated_explanations"`
       - `pytest -q -m "not viz"` (or equivalent marker filter if present).
    - Ensure plotting modules keep lazy imports.

### 9.3 Decision (v0.11.0)

- Keep `ParallelExecutor` canonical and add `ParallelFacade` alias.
- Record the decision via a short ADR-004 addendum.

### 9.4 Verification checklist

- A clean environment without matplotlib can import `calibrated_explanations`.
- CI reports core-only job green.
- Unit tests cover `ParallelFacade` alias stability.

---

## 10) ADR-027 + ADR-028: Observability enforcement (examples + lint/tests)

**Goal:** Close observability enforcement by adding logging/observability
examples and tests, aligned with Standard-005.

### 10.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/improvement/adrs/ADR-027-fast-feature-filtering.md](docs/improvement/adrs/ADR-027-fast-feature-filtering.md)** — feature filtering behavior that must emit governance logs.
- **[docs/improvement/adrs/ADR-028-logging-and-governance-observability.md](docs/improvement/adrs/ADR-028-logging-and-governance-observability.md)** — logging domains/fields and governance observability expectations.
- **[docs/standards/STD-005-logging-and-observability-standard.md](docs/standards/STD-005-logging-and-observability-standard.md)** — the enforcement standard for observability.
- [docs/standards/STD-003-test-coverage-standard.md](docs/standards/STD-003-test-coverage-standard.md) — tests for logging behavior.
- [.github/tests-guidance.md](.github/tests-guidance.md) — caplog assertion patterns.

### 10.1 Current anchors in code

- Logging context helper exists: `src/calibrated_explanations/logging.py` (`ensure_logging_context_filter`).
- Feature filter already uses governance logger name and context filter:
  `src/calibrated_explanations/core/explain/_feature_filter.py`.

### 10.2 Implementation steps

1. **Examples (docs).**
    - Add examples showing how to configure logging in a host application:
       - text formatter
       - JSON formatter
       - governance logger routing
    - Place them in the governance/observability documentation area.

2. **Tests (caplog).**
    - Add unit tests that assert:
       - governance events use `calibrated_explanations.governance.*` loggers,
       - expected structured fields appear when set.

3. **Enforcement tooling.**
    - Add a lightweight lint check (script) or extend existing scripts to
       validate logger domain usage in touched modules.

### 10.3 Verification checklist

- Tests validate logger names/domains.
- Docs contain runnable snippets (kept lightweight).

---

## 11) Standard-004: Plot plugin authoring + override guidance

**Goal:** Publish plot plugin authoring/override guidance consistent with the
audience-hub documentation structure.

### 11.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/standards/STD-004-documentation-audience-standard.md](docs/standards/STD-004-documentation-audience-standard.md)** — required documentation structure and audience hubs.
- [docs/improvement/adrs/ADR-014-plot-plugin-strategy.md](docs/improvement/adrs/ADR-014-plot-plugin-strategy.md) — plot plugin architecture.
- [docs/improvement/adrs/ADR-007-visualization-abstraction-layer.md](docs/improvement/adrs/ADR-007-visualization-abstraction-layer.md) — visualization abstraction constraints.
- [docs/improvement/adrs/ADR-016-plot-spec-separation.md](docs/improvement/adrs/ADR-016-plot-spec-separation.md) — PlotSpec separation guidelines.

### 11.1 Implementation steps

1. Add a contributor-facing document that:
    - explains the plot plugin interfaces,
    - describes override precedence (keyword/env/pyproject/registry),
    - references PlotSpec usage (ADR-007/ADR-016/ADR-014/ADR-017 lineage as applicable).
2. Add a minimal example that is runnable headlessly.

### 11.2 Verification checklist

- Linked from the contributors hub.
- Example runs in docs CI or a smoke test.

---

## 12) Standard-001: Nomenclature cleanup completion tasks

**Goal:** Eliminate double-underscore mutations, split utilities, report lint
telemetry, and confine transitional shims to `legacy/`.

### 12.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/standards/STD-001-nomenclature-standardization.md](docs/standards/STD-001-nomenclature-standardization.md)** — canonical naming rules and cleanup targets.
- **[docs/improvement/Standard-001_nomenclature_remediation.md](docs/improvement/Standard-001_nomenclature_remediation.md)** — step-by-step remediation roadmap.
- [docs/improvement/PATTERN_1_REMEDIATION_PLAN.md](docs/improvement/PATTERN_1_REMEDIATION_PLAN.md) — related private-member remediation context.
- [docs/standards/STD-002-code-documentation-standard.md](docs/standards/STD-002-code-documentation-standard.md) — docstring/code documentation expectations while refactoring.

### 12.1 Implementation steps

1. **Double-underscore removal.**
    - Identify remaining accesses like `_Class__attr` and replace with accessors
       or protected fields.
2. **Utility splitting.**
    - Split `utils/helper.py` responsibilities into focused modules (see
       `docs/improvement/Standard-001_nomenclature_remediation.md`).
3. **Lint/telemetry reporting.**
    - Ensure naming-lint tooling exists and emit a governance/telemetry summary
       suitable for dashboards.
4. **Legacy confinement.**
    - Ensure all transitional shims live under `src/calibrated_explanations/legacy/`.

### 12.2 Verification checklist

- No new double-underscore accesses.
- Internal imports point to canonical modules.

---

## 13) Governance dashboards: surface lint status + preprocessing/domain telemetry

**Goal:** Extend dashboards/telemetry documentation so maintainers can monitor
lint status alongside preprocessing/domain-model telemetry.

### 13.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/improvement/adrs/ADR-028-logging-and-governance-observability.md](docs/improvement/adrs/ADR-028-logging-and-governance-observability.md)** — governance telemetry/logging requirements.
- [docs/improvement/adrs/ADR-009-input-preprocessing-and-mapping-policy.md](docs/improvement/adrs/ADR-009-input-preprocessing-and-mapping-policy.md) — preprocessing telemetry/mapping snapshot signals.
- **[docs/standards/STD-005-logging-and-observability-standard.md](docs/standards/STD-005-logging-and-observability-standard.md)** — what “observability compliant” means.
- [.github/GOVERNANCE.md](.github/GOVERNANCE.md) — governance reporting conventions and where dashboards belong.

### 13.1 Implementation steps

1. Define the “lint status” signal:
    - source (script output, CI job status, generated report)
    - format (JSON report artifact, log line, badge)
      - Minimal JSON artifact format includes: `component`, `check_name`,
         `status`, `details_url`, `timestamp`.
2. Document how to publish/consume it in governance docs.

### 13.2 Verification checklist

- A single documented workflow exists for maintainers to retrieve lint status
   and preprocessing/domain-model signals.

---

## 14) Default change: `condition_source="prediction"`

**Goal:** Change the default behavior for `condition_source` to `"prediction"`
and update docs and upgrade guidance.

### 14.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- [docs/improvement/adrs/ADR-005-explanation-json-schema-versioning.md](docs/improvement/adrs/ADR-005-explanation-json-schema-versioning.md) — metadata fields and compatibility expectations.
- [docs/improvement/adrs/ADR-008-explanation-domain-model-and-compat.md](docs/improvement/adrs/ADR-008-explanation-domain-model-and-compat.md) — domain-model semantics that surface `condition_source`.
- [docs/standards/STD-003-test-coverage-standard.md](docs/standards/STD-003-test-coverage-standard.md) — tests for default changes.
- [docs/improvement/remediation_api_changes.md](docs/improvement/remediation_api_changes.md) — user-visible migration notes (if this is a breaking/behavioral change).

### 14.1 Current anchors in code

- `CalibratedExplainer` currently defaults to `"observed"`:
  `src/calibrated_explanations/core/calibrated_explainer.py`.
- Explanation collections also default to `"observed"`:
  `src/calibrated_explanations/explanations/explanations.py`.

### 14.2 Implementation steps

1. Change defaults to `"prediction"` while preserving explicit override.
2. Update docs where `condition_source` is explained.
3. Add an upgrade note and a quick checklist for users who relied on observed labels.
4. Add a compatibility checker that issues a one-time visible warning when the
   old behavior is detected during `fit`.

### 14.3 Verification checklist

- Unit tests cover default behavior and explicit override.
- Documentation mentions the default change and migration.

---

## 15) Pattern 1 hardening: empty `.github/private_member_allowlist.json`

**Goal:** Empty the private member allowlist as part of final remediation.

### 15.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — v0.11.0 task definition and release gates.
- **[docs/improvement/PATTERN_1_REMEDIATION_PLAN.md](docs/improvement/PATTERN_1_REMEDIATION_PLAN.md)** — remediation scope and definition of “Pattern 1”.
- **[.github/private_member_allowlist.json](.github/private_member_allowlist.json)** — artifact that must become empty.
- [docs/improvement/ANTI_PATTERN_REMEDIATION_PLAN.md](docs/improvement/ANTI_PATTERN_REMEDIATION_PLAN.md) — related remediation workflow.
- [docs/standards/STD-001-nomenclature-standardization.md](docs/standards/STD-001-nomenclature-standardization.md) — discourages private-member coupling and renames.

### 15.1 Current state

- Allowlist exists: `.github/private_member_allowlist.json`.
- Repo includes helper scripts, but `scripts/prune_allowlist.py` is currently
   hardcoded to a local path and should not be relied upon without fixing.

### 15.2 Implementation steps

1. Refactor remaining allowlisted tests to avoid private member usage.
2. Fix or replace the `scripts/prune_allowlist.py` script so it is portable
   (remove hardcoded paths) and can be used to re-generate the allowlist cleanly.
3. Set `allowlist` to an empty array.
4. Ensure the private-member scan CI gate remains green.
5. Add a CI job that runs the private-member scan on a fresh checkout and
   fails if private members are used.

### 15.3 Verification checklist

- CI private-member scan passes with an empty allowlist.

---

## 16) Final gap sweep: ADRs, standards, improvement docs + appendix update

**Goal:** Perform a final sweep and update any remaining gaps, ensuring the
release appendix reflects reality.

### 16.0 Relevant references

- **[docs/improvement/RELEASE_PLAN_v1.md](docs/improvement/RELEASE_PLAN_v1.md)** — release gate checklist, v0.11.0 task list, and appendix gap log.
- **[docs/improvement/adrs/ADR-004-parallel-backend-abstraction.md](docs/improvement/adrs/ADR-004-parallel-backend-abstraction.md)**, **[ADR-005](docs/improvement/adrs/ADR-005-explanation-json-schema-versioning.md)**, **[ADR-008](docs/improvement/adrs/ADR-008-explanation-domain-model-and-compat.md)**, **[ADR-009](docs/improvement/adrs/ADR-009-input-preprocessing-and-mapping-policy.md)**, **[ADR-010](docs/improvement/adrs/ADR-010-core-vs-evaluation-split-and-distribution.md)**, **[ADR-012](docs/improvement/adrs/ADR-012-documentation-and-gallery-build-policy.md)**, **[ADR-020](docs/improvement/adrs/ADR-020-legacy-user-api-stability.md)**, **[ADR-026](docs/improvement/adrs/ADR-026-explanation-plugin-semantics.md)**, **[ADR-027](docs/improvement/adrs/ADR-027-fast-feature-filtering.md)**, **[ADR-028](docs/improvement/adrs/ADR-028-logging-and-governance-observability.md)**, **[ADR-030](docs/improvement/adrs/ADR-030-test-quality-priorities-and-enforcement.md)**, **[ADR-031](docs/improvement/adrs/ADR-031-calibrator-serialization-and-state-persistence.md)** — v0.11.0 primary ADR gate set.
- **[docs/standards/STD-001-nomenclature-standardization.md](docs/standards/STD-001-nomenclature-standardization.md)**, **[STD-002](docs/standards/STD-002-code-documentation-standard.md)**, **[STD-003](docs/standards/STD-003-test-coverage-standard.md)**, **[STD-004](docs/standards/STD-004-documentation-audience-standard.md)**, **[STD-005](docs/standards/STD-005-logging-and-observability-standard.md)** — standards to re-check at ship time.
- [CHANGELOG.md](CHANGELOG.md) — ensure shipped items are reflected.
- [docs/improvement/legacy_user_api_contract.md](docs/improvement/legacy_user_api_contract.md) — validate legacy contract changes are intentional.
- [.github/GOVERNANCE.md](.github/GOVERNANCE.md) — governance reporting/checklist expectations.

### 16.1 Implementation steps

1. Re-run all “health” scripts relevant to v0.11.0:
    - test suite, coverage gates, anti-pattern scans, notebook audit.
2. Update ADR status notes if implementation changes semantics.
3. Update the release plan appendix gap log for any newly-closed items.

### 16.2 Verification checklist

- All gates for v0.11.0 are green.
- Appendix reflects closed gaps.

---

## Release gate summary

v0.11.0 can ship when the items above are completed or explicitly deferred per
ADR policy, and the following are green:

- `pytest -q`
- ADR-030 test-quality tooling in CI
- Core-only import path verified (no matplotlib required)
- Docs execution job runs notebooks with time ceilings (release-branch blocking)
- Legacy API audit workflow is in place
