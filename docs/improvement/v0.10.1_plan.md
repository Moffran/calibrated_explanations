# v0.10.1 Release Task Implementation Plan

This plan expands the v0.10.1 tasks from `docs/improvement/RELEASE_PLAN_v1.md` with
implementation details grounded in ADRs and current code layout. Each section
lists the concrete work items, impacted modules, verification steps, and open
questions needed to satisfy the release gate.

## Source references reviewed

- Release task list: `docs/improvement/RELEASE_PLAN_v1.md` (v0.10.1 section + ADR status appendix).
- ADRs: `docs/improvement/adrs/ADR-005-explanation-json-schema-versioning.md`,
  `ADR-007-visualization-abstraction-layer.md`, `ADR-014-plot-plugin-strategy.md`,
  `ADR-016-plot-spec-separation.md`, `ADR-024-legacy-plot-input-contracts.md`,
  `ADR-025-legacy-plot-rendering-semantics.md`, `ADR-018-code-documentation-standard.md`.
- PlotSpec docs: `docs/improvement/plot_spec/PLOTSPEC_SCHEMA.md`,
  `docs/improvement/plot_spec/PRIMITIVES_SCHEMA.md`.
- Anti-pattern remediation: `docs/improvement/ANTI_PATTERN_REMEDIATION_PLAN.md`.
- Code/documentation uplift guide: `docs/improvement/code_documentation_uplift.md`.

---

## 1) ADR-005 Explanation envelope & schema contract

**Goal:** Replace the legacy flat JSON payload with the ADR-005 envelope and
ship a validation + fixture refresh while preserving backward compatibility for
existing exports/imports.

**Key ADR gaps to close (from ADR-005 appendix):**
- Envelope absent, no `type` registry, missing `generator.parameters_hash`.
- `validate_payload` not enforcing envelope semantics.
- `schema_version` optional and docs/fixtures still describe the legacy shape.

**Implementation steps**
1. **Introduce a versioned envelope model and registry.**
   - Add a new envelope schema directory (e.g., `src/calibrated_explanations/schemas/v1/`) with:
     - a top-level envelope schema (type, generator, meta, payload).
     - per-type payload schemas (`feature_attribution`, `interval`, `global_importance`,
       `calibration_diagnostics`) referenced by the envelope.
   - Add a registry of explanation `type` discriminants (new module, e.g.
     `src/calibrated_explanations/schema/registry.py`) to map `type` to schema
     file names and to validate allowable values.

2. **Update serialization to emit the envelope while keeping legacy adapters.**
   - Extend `src/calibrated_explanations/serialization.py` to build the ADR-005
     envelope (`schema_version`, `type`, `explanation_type`, `generator`, `meta`,
     `payload`).
   - Introduce a new helper to compute `generator.parameters_hash` based on
     the explainer/config state (e.g., hashing `CalibratedExplainer` metadata,
     feature list, bins, threshold). Store in `generator.parameters_hash`.
   - Keep legacy flat payload exporters for compatibility and ensure
     `ExportedExplanationCollection.to_json()` in
     `src/calibrated_explanations/explanations/explanations.py` can emit either
     legacy or envelope depending on an opt-in flag (default to new envelope for
     v0.10.1).

3. **Align validation helpers with the envelope.**
   - Update `src/calibrated_explanations/schema/validation.py` and the
     re-export in `src/calibrated_explanations/serialization.py` to validate
     the envelope schema rather than the flat v1 payload.
   - Enforce `schema_version` as required and semver-validated.

4. **Update docs + fixtures.**
   - Update `docs/schema_v1.md` to reflect the envelope fields and the
     per-type payload routing; add a section describing `generator` and `meta`.
   - Refresh fixtures/tests in `tests/` that reference the old flat schema,
     including round-trip tests (`tests/test_serialization_and_quick.py`).

**Open questions**
- Should the envelope become the default for `CalibratedExplanations.to_json` in v0.10.1,
  or do we keep legacy-by-default and introduce a new explicit `to_envelope` API?
- What exact fields must be included in `generator.parameters_hash` to ensure stable,
  reproducible hashes without leaking sensitive data?
- How should we version the envelope directory (`schemas/v1/`) relative to the existing
  `schemas/explanation_schema_v1.json` to avoid breaking imports or tests?

**Verification checklist**
- New envelope fixtures validate via `jsonschema`.
- Round-trip tests pass for legacy-to-envelope and envelope-to-domain flows.
- `validate_payload` rejects missing/invalid `type`, `schema_version`, or
  `generator.parameters_hash`.

---

## 2) ADR-007 + ADR-016 PlotSpec schema/registry/round-trip

**Goal:** Finalize PlotSpec schema metadata, registries, validation, and
headless export support, aligning with ADR-007/ADR-016 gaps.

**Key ADR gaps to close**
- `PlotSpec` missing `kind`/`mode`/`feature_order`/`version` fields and
  `save_behavior` metadata.
- Validation is bar-only and builders skip validation.
- JSON round-trip inconsistent for triangular/global specs.
- No headless export support and no plot kind registry.

**Implementation steps**
1. **Extend PlotSpec dataclasses.**
   - Update `src/calibrated_explanations/viz/plotspec.py` with:
     - required fields: `kind`, `mode`, `feature_order`.
     - version field (PlotSpec schema version distinct from explanation schema).
     - `save_behavior` structure (`path`, `title`, `default_exts`).
   - Add a `PlotKindRegistry` (new module or part of
     `viz/serializers.py`) for supported kinds and versioned validation.

2. **Update serialization and validation.**
   - Extend `src/calibrated_explanations/viz/serializers.py` to round-trip new
     fields and enforce `kind`-aware validation (different requirements per
     `factual_probabilistic`, `alternative_probabilistic`, `triangular`,
     `global_*`, etc.).
   - Adjust `validate_plotspec` to accept non-panel dict payloads for
     triangular/global plots while still validating required metadata fields.

3. **Ensure builders call validation and preserve feature order.**
   - Update `src/calibrated_explanations/viz/builders.py` to:
     - call `validate_plotspec` before returning payloads.
     - preserve `feature_order` from callers instead of renumbering.
     - set `mode`, `kind`, and `save_behavior` consistently.

4. **Add headless export support.**
   - Extend `src/calibrated_explanations/viz/matplotlib_adapter.py` to allow
     rendering directly to bytes (e.g., PNG/SVG) when `show=False` and
     `save_behavior` requests a headless export.
   - Add tests to verify byte outputs for PlotSpec rendering.

**Open questions**
- Should triangular/global PlotSpec payloads migrate from dict-style shims to
  dedicated dataclasses in v0.10.1, or is it acceptable to keep dict payloads
  with stricter validation?
- Where should the PlotSpec schema version live (dataclass field vs. envelope
  dict-only field) to minimize breakage for adapters and tests?
- Do we need a separate JSON schema file for PlotSpec or is the existing
  `viz/serializers.validate_plotspec` sufficient for v0.10.1?

**Verification checklist**
- JSON round-trips for bar, triangular, and global PlotSpecs are stable.
- Builders call validation in tests.
- Headless export returns bytes and honors `save_behavior`.

---

## 3) ADR-014 Visualization plugin architecture completion

**Goal:** Restore the full plot plugin architecture: functional legacy fallback,
helper base classes, metadata alignment, override resolution, validation hooks,
CLI tooling, and docs.

**Key ADR gaps to close**
- Legacy fallback plugin inert, no base classes, missing default renderer.
- Renderer override resolution ignores env/kwargs.
- Missing `PlotPluginError`, validation hooks, CLI helpers, and docs.

**Implementation steps**
1. **Finalize plugin API + helpers.**
   - Add helper base classes to `src/calibrated_explanations/viz/plugins.py`
     (e.g., `BasePlotBuilder`, `BasePlotRenderer`) with lifecycle hooks and
     `validate_plotspec` integration.
   - Introduce a `PlotPluginError` in `src/calibrated_explanations/utils/exceptions.py`.

2. **Ensure a working legacy fallback plugin.**
   - Register a legacy builder/renderer pair in `src/calibrated_explanations/plugins/builtins.py`
     that delegates to `legacy.plotting` with `show/path/save_ext` semantics.
   - Ensure the default style in the registry resolves to legacy when no
     overrides are configured.

3. **Align metadata and resolution order.**
   - Extend plot plugin metadata to include `default_renderer` (update
     `validate_plot_builder_metadata` in `src/calibrated_explanations/plugins/registry.py`).
   - Update `src/calibrated_explanations/plotting.py` to honor:
     - explicit `renderer`/`style` kwargs,
     - environment overrides (`CE_PLOT_RENDERER`, `CE_PLOT_STYLE`),
     - pyproject configuration in `[tool.calibrated_explanations.plots]`.

4. **CLI tooling + documentation.**
   - Add CLI commands in `src/calibrated_explanations/plugins/cli.py`:
     - `ce.plugins list --plots` (verify output),
     - `ce.plugins validate-plot --builder <id>`,
     - `ce.plugins set-default --plot-style <id>`.
   - Add a “Writing plot plugins” guide in `docs/plugins.md` or a new
     contributor doc with examples and migration notes.

**Open questions**
- Should plot plugin base classes live under `viz/` or `plugins/` to best match
  the ownership boundaries from ADR-001?
- Do we need to rename or version existing plot plugin IDs (`core.plot.legacy`,
  `plot_spec.default`) to align with the new `default_renderer` metadata?
- How should `PlotPluginError` be surfaced to users to avoid breaking existing
  exception handling in `.plot()` workflows?

**Verification checklist**
- `.plot()` resolves legacy fallback when no plugin configured.
- Override paths and fallbacks work in tests.
- CLI commands return expected output and error messages.

---

## 4) ADR-024 + ADR-025 legacy plotting alignment

**Goal:** Bring legacy plotting helpers into full contract compliance and add
missing coverage for rendering semantics and guardrails.

**Key ADR gaps to close**
- `_plot_global` ignores `show=False` and lacks save parameters.
- Regression plots lack symmetric axes / interval backdrop behaviors.
- Matplotlib guard allows silent skips; missing tests for warnings/one-sided.

**Implementation steps**
1. **Fix input contracts in legacy plotting.**
   - Update `_plot_global` in `src/calibrated_explanations/legacy/plotting.py` to:
     - honor `show=False` (avoid `plt.show()` in headless mode),
     - accept `path/title/save_ext` with the same concatenation rules as other
       helpers, and
     - call `__require_matplotlib()` only when `show=True` or save output is
       requested.

2. **Restore rendering semantics.**
   - Reinstate symmetric x-axis enforcement for regression plots
     (`_plot_regression`) and ensure interval backdrops (`fill_betweenx`)
     are drawn when required.
   - Re-enable interval backdrop for regression and alternative plots to match
     ADR-025 section details.

3. **Matplotlib guard and warnings.**
   - Ensure guard checks raise when Matplotlib is missing but output is
     requested (`show=True` or `path/title` present).
   - Add explicit tests for one-sided interval warnings and for `show=False`
     behavior to prevent regressions.

**Open questions**
- Should `_plot_global` accept `path`/`title` parameters directly to match other
  helpers, or should we add a wrapper in `plotting.py` that injects save behavior?
- Do we need a compatibility flag to preserve existing `_plot_global` interactive
  behavior for users who rely on `plt.show()` side effects?
- Which specific plots should get golden-image coverage vs. semantic-only tests
  to keep CI stable?

**Verification checklist**
- Legacy plotting matches ADR-024/ADR-025 behaviors.
- New/updated tests cover `_plot_global` headless mode and save behavior.

---

## 5) ADR-018 docstrings for dynamic visualization classes

**Goal:** Close the remaining docstring gap for dynamically generated classes
used in plot plugin composition.

**Implementation steps**
1. **Document combined plot plugin classes.**
   - Add docstrings to `CombinedPlotPlugin` classes created in
     `src/calibrated_explanations/plugins/registry.py` (both trusted and
     untrusted paths) describing their purpose and methods.
   - If using `type()` or closures for dynamic class creation, set
     `__doc__` explicitly to satisfy pydocstyle.

2. **Verify docstring coverage.**
   - Run docstring linting (if available) or add tests ensuring
     dynamically generated classes have non-empty docstrings.

**Open questions**
- Should the combined plugin wrapper become a named class in `plugins/plots.py`
  to avoid repeated nested class definitions and improve docstring linting?
- Do we need to update ADR-018 tracking artifacts (e.g., baseline docstring
  report) when we change the registry implementation?

**Verification checklist**
- Docstring linting passes for registry-generated classes.

---

## 6) Streaming-friendly explanation delivery (experimental)

**Goal:** Provide an opt-in streaming export for large explanation collections
without breaking existing APIs, and capture export telemetry.

**Implementation steps**
1. **Streaming API surface.**
   - Add a generator API in `src/calibrated_explanations/explanations/explanations.py`:
     - `to_json_stream(chunk_size=256, format="jsonl" | "chunked")` or
       `to_json(stream=True, chunk_size=...)`.
   - Stream by serializing explanations in chunks, yielding either JSON Lines
     or chunked JSON arrays (consistent with ADR-005 envelope format).

2. **Telemetry instrumentation.**
   - Add export telemetry fields: `export_rows`, `chunk_size`, `mode`,
     `peak_memory_mb`, `elapsed_seconds`, `schema_version`, `feature_branch`.
   - Store telemetry in the explanation collection metadata or in the
     explainer’s `_last_telemetry` record (via
     `src/calibrated_explanations/core/explain/orchestrator.py`).

3. **Memory profiling validation.**
   - Add a benchmark/test utility (e.g., under `scripts/`) to validate
     `10k rows < 200MB at chunk_size=256` and capture performance numbers.
   - Mark the feature experimental in `CHANGELOG.md` and update docs.

**Open questions**
- Should streaming use JSON Lines by default or chunked JSON arrays for better
  downstream compatibility?
- Where should export telemetry live (collection metadata vs. explainer telemetry)
  to avoid mixing runtime explain telemetry with export-only metrics?
- Is the `feature_branch` telemetry field intended to capture git metadata, or
  should it reflect an explanation feature flag (e.g., streaming on/off)?

**Verification checklist**
- Streaming exports yield valid JSON and preserve schema version.
- Telemetry fields are populated.
- Memory profile target documented with benchmark output.

---

## 7) Anti-pattern remediation Phase 2 (Category A)

**Goal:** Refactor tests that call private methods to use public APIs and remove
any dead private helpers uncovered during the refactor.

**Implementation steps**
1. **Inventory Category A calls.**
   - Add/extend a scan script (e.g., `scripts/scan_private_usage.py`) to
     enumerate private-member usage under `tests/` and group by symbol name.
   - Prioritize Category A calls (internal logic testing) for v0.10.1.

2. **Refactor tests to public APIs.**
   - Update tests to use `CalibratedExplainer` / `WrapCalibratedExplainer`
     public methods rather than direct private access.
   - If a test requires a private-only state, either expose a public factory
     (non-underscore) or update the test to reach the state via a supported
     workflow.

3. **Remove dead code.**
   - Delete private methods that are only referenced by tests (after verifying
     no runtime usage).
   - Add replacement tests that cover the same behavior through public APIs.

4. **Enforce and validate.**
   - Add a CI guard (lint/test step) to prevent new private-member usage in
     tests.

**Open questions**
- What thresholds or allowlist should the new CI guard use to avoid blocking
  unrelated test work while remediation is in progress?
- Are there Category A call sites that should remain temporarily due to missing
  public API equivalents, and if so, what explicit waivers should be recorded?
- Should the remediation effort include test helper renames (Category B) if they
  are touched during Category A refactors?

**Verification checklist**
- Category A tests no longer call private members.
- Coverage remains unchanged or improves.

---

## Release gate alignment

The following release gates map directly to this plan:
- **Envelope + schema**: validated round-trips and fixtures updated.
- **PlotSpec + plugin registry**: PlotSpec validation, registry completeness,
  and legacy plugin fallback verified.
- **Legacy plotting**: ADR-024/ADR-025 behaviors enforced with tests.
- **Docs**: schema, plot plugin, and streaming docs updated.
