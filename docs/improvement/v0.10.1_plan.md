# v0.10.1 Release Task Implementation Plan

This plan expands the v0.10.1 tasks from `docs/improvement/RELEASE_PLAN_v1.md` with
implementation details grounded in ADRs and current code layout. Each section
lists the concrete work items, impacted modules, verification steps, and open
questions needed to satisfy the release gate.

## Source references reviewed

- Release task list: `docs/improvement/RELEASE_PLAN_v1.md` (v0.10.1 section + ADR status appendix).
- ADRs: `docs/improvement/adrs/ADR-005-explanation-json-schema-versioning.md`,
  `ADR-007-visualization-abstraction-layer.md`, `ADR-014-plot-plugin-strategy.md`,
  `ADR-016-plot-spec-separation.md`, `ADR-024-legacy-plot-input-contracts.md`,
  `ADR-025-legacy-plot-rendering-semantics.md`, `ADR-018-code-documentation-standard.md`.
- PlotSpec docs: `docs/improvement/plot_spec/PLOTSPEC_SCHEMA.md`,
  `docs/improvement/plot_spec/PRIMITIVES_SCHEMA.md`.
- Anti-pattern remediation: `docs/improvement/ANTI_PATTERN_REMEDIATION_PLAN.md`.
- Code/documentation uplift guide: `docs/improvement/code_documentation_uplift.md`.

---

## 1) ADR-005 Explanation envelope & schema contract

**Goal:** Replace the legacy flat JSON payload with the ADR-005 envelope and
ship a validation + fixture refresh while preserving backward compatibility for
existing exports/imports.

**Key ADR gaps to close (from ADR-005 appendix):**
- Envelope absent, no `type` registry, missing `generator.parameters_hash`.
- `validate_payload` not enforcing envelope semantics.
- `schema_version` optional and docs/fixtures still describe the legacy shape.

**Implementation steps**
1. **Introduce a versioned envelope model and registry.**
   - Add a new envelope schema directory (e.g., `src/calibrated_explanations/schemas/v1/`) with:
     - a top-level envelope schema (type, generator, meta, payload).
     - per-type payload schemas (`feature_attribution`, `interval`, `global_importance`,
       `calibration_diagnostics`) referenced by the envelope.
   - Add a registry of explanation `type` discriminants (new module, e.g.
     `src/calibrated_explanations/schema/registry.py`) to map `type` to schema
     file names and to validate allowable values.

2. **Update serialization to emit the envelope while keeping legacy adapters.**
   - Extend `src/calibrated_explanations/serialization.py` to build the ADR-005
     envelope (`schema_version`, `type`, `explanation_type`, `generator`, `meta`,
     `payload`).
   - Introduce a new helper to compute `generator.parameters_hash` based on
     the explainer/config state (e.g., hashing `CalibratedExplainer` metadata,
     feature list, bins, threshold). Store in `generator.parameters_hash`.
   - Keep legacy flat payload exporters for compatibility and ensure
     `ExportedExplanationCollection.to_json()` in
     `src/calibrated_explanations/explanations/explanations.py` can emit either
     legacy or envelope depending on an opt-in flag (default to new envelope for
     v0.10.1).

3. **Align validation helpers with the envelope.**
   - Update `src/calibrated_explanations/schema/validation.py` and the
     re-export in `src/calibrated_explanations/serialization.py` to validate
     the envelope schema rather than the flat v1 payload.
   - Enforce `schema_version` as required and semver-validated.

4. **Update docs + fixtures.**
   - Update `docs/schema_v1.md` to reflect the envelope fields and the
     per-type payload routing; add a section describing `generator` and `meta`.
   - Refresh fixtures/tests in `tests/` that reference the old flat schema,
     including round-trip tests (`tests/test_serialization_and_quick.py`).

**Decisions**
- Make the ADR-005 envelope the default for `CalibratedExplanations.to_json` in v0.10.1;
  keep legacy export only as an explicit opt-in compatibility path.
- Compute `generator.parameters_hash` from deterministic, non-sensitive configuration
  inputs plus core library versions to improve reproducibility without leaking data.
- Version schemas under `schemas/v1/` and treat the legacy flat schema as deprecated
  (remove it from the primary schema path for v0.10.1).
- Make the envelope carry an optional audit/provenance block (correlation_id, policy_version, environment) so exports are self-describing. Optional block with fixed keys; default empty.
- 

**Verification checklist**
- New envelope fixtures validate via `jsonschema`.
- Round-trip tests pass for legacy-to-envelope and envelope-to-domain flows.
- `validate_payload` rejects missing/invalid `type`, `schema_version`, or
  `generator.parameters_hash`.

---

## 2) ADR-007 + ADR-016 PlotSpec schema/registry/round-trip

**Goal:** Finalize PlotSpec schema metadata, registries, validation, and
headless export support, aligning with ADR-007/ADR-016 gaps.

**Key ADR gaps to close**
- `PlotSpec` missing `kind`/`mode`/`feature_order`/`version` fields and
  `save_behavior` metadata.
- Validation is bar-only and builders skip validation.
- JSON round-trip inconsistent for triangular/global specs.
- No headless export support and no plot kind registry.

**Implementation steps**
1. **Extend PlotSpec dataclasses.**
   - Update `src/calibrated_explanations/viz/plotspec.py` with:
     - required fields: `kind`, `mode`, `feature_order`.
     - version field (PlotSpec schema version distinct from explanation schema).
     - `save_behavior` structure (`path`, `title`, `default_exts`).
   - Add a `PlotKindRegistry` (new module or part of
     `viz/serializers.py`) for supported kinds and versioned validation.

2. **Update serialization and validation.**
   - Extend `src/calibrated_explanations/viz/serializers.py` to round-trip new
     fields and enforce `kind`-aware validation (different requirements per
     `factual_probabilistic`, `alternative_probabilistic`, `triangular`,
     `global_*`, etc.).
   - Adjust `validate_plotspec` to accept non-panel dict payloads for
     triangular/global plots while still validating required metadata fields.

3. **Ensure builders call validation and preserve feature order.**
   - Update `src/calibrated_explanations/viz/builders.py` to:
     - call `validate_plotspec` before returning payloads.
     - preserve `feature_order` from callers instead of renumbering.
     - set `mode`, `kind`, and `save_behavior` consistently.

4. **Add headless export support.**
   - Extend `src/calibrated_explanations/viz/matplotlib_adapter.py` to allow
     rendering directly to bytes (e.g., PNG/SVG) when `show=False` and
     `save_behavior` requests a headless export.
   - Add tests to verify byte outputs for PlotSpec rendering.

**Decisions**
- Migrate triangular/global PlotSpec payloads to dedicated dataclasses in v0.10.1.
- Store PlotSpec schema version as an explicit dataclass field (serialized in JSON).
- Add a separate JSON schema file for PlotSpec in v0.10.1 to align with explanation
  schema validation.
- Make PlotSpec include optional provenance fields (data_slice_id, rendering_seed) for reproducible audits.

**Verification checklist**
- JSON round-trips for bar, triangular, and global PlotSpecs are stable.
- Builders call validation in tests.
- Headless export returns bytes and honors `save_behavior`.

---

## 3) ADR-014 Visualization plugin architecture completion

**Goal:** Restore the full plot plugin architecture: functional legacy fallback,
helper base classes, metadata alignment, override resolution, validation hooks,
CLI tooling, and docs.

**Key ADR gaps to close**
- Legacy fallback plugin inert, no base classes, missing default renderer.
- Renderer override resolution ignores env/kwargs.
- Missing `PlotPluginError`, validation hooks, CLI helpers, and docs.

**Implementation steps**
1. **Finalize plugin API + helpers.**
   - Add helper base classes to `src/calibrated_explanations/viz/plugins.py`
     (e.g., `BasePlotBuilder`, `BasePlotRenderer`) with lifecycle hooks and
     `validate_plotspec` integration.
   - Introduce a `PlotPluginError` in `src/calibrated_explanations/utils/exceptions.py`.

2. **Ensure a working legacy fallback plugin.**
   - Register a legacy builder/renderer pair in `src/calibrated_explanations/plugins/builtins.py`
     that delegates to `legacy.plotting` with `show/path/save_ext` semantics.
   - Ensure the default style in the registry resolves to legacy when no
     overrides are configured.

3. **Align metadata and resolution order.**
   - Extend plot plugin metadata to include `default_renderer` (update
     `validate_plot_builder_metadata` in `src/calibrated_explanations/plugins/registry.py`).
   - Update `src/calibrated_explanations/plotting.py` to honor:
     - explicit `renderer`/`style` kwargs,
     - environment overrides (`CE_PLOT_RENDERER`, `CE_PLOT_STYLE`),
     - pyproject configuration in `[tool.calibrated_explanations.plots]`.

4. **CLI tooling + documentation.**
   - Add CLI commands in `src/calibrated_explanations/plugins/cli.py`:
     - `ce.plugins list --plots` (verify output),
     - `ce.plugins validate-plot --builder <id>`,
     - `ce.plugins set-default --plot-style <id>`.
   - Add a “Writing plot plugins” guide in `docs/plugins.md` or a new
     contributor doc with examples and migration notes.

**Decisions**
- Place plot plugin base classes in `plugins/` with visualization adapters in `viz/`
  to preserve a clear plugin boundary.
- Keep existing plot plugin IDs stable and add versioning via metadata fields.
- Surface `PlotPluginError` directly for invalid plugin usage to provide explicit,
  auditable failures in `.plot()` workflows.

**Verification checklist**
- `.plot()` resolves legacy fallback when no plugin configured.
- Override paths and fallbacks work in tests.
- CLI commands return expected output and error messages.

---

## 4) ADR-024 + ADR-025 legacy plotting alignment

**Goal:** Bring legacy plotting helpers into full contract compliance and add
missing coverage for rendering semantics and guardrails.

**Key ADR gaps to close**
- `_plot_global` ignores `show=False` and lacks save parameters.
- Regression plots lack symmetric axes / interval backdrop behaviors.
- Matplotlib guard allows silent skips; missing tests for warnings/one-sided.

**Implementation steps**
1. **Fix input contracts in legacy plotting.**
   - Update `_plot_global` in `src/calibrated_explanations/legacy/plotting.py` to:
     - honor `show=False` (avoid `plt.show()` in headless mode),
     - accept `path/title/save_ext` with the same concatenation rules as other
       helpers, and
     - call `__require_matplotlib()` only when `show=True` or save output is
       requested.

2. **Restore rendering semantics.**
   - Reinstate symmetric x-axis enforcement for regression plots
     (`_plot_regression`) and ensure interval backdrops (`fill_betweenx`)
     are drawn when required.
   - Re-enable interval backdrop for regression and alternative plots to match
     ADR-025 section details.

3. **Matplotlib guard and warnings.**
   - Ensure guard checks raise when Matplotlib is missing but output is
     requested (`show=True` or `path/title` present).
   - Add explicit tests for one-sided interval warnings and for `show=False`
     behavior to prevent regressions.

**Decisions**
- Update `_plot_global` to accept `path`/`title` parameters directly for consistent
  save behavior with other helpers.
- Do not add a compatibility flag for interactive-only `plt.show()` side effects;
  default to headless-safe behavior when `show=False`.
- Prefer semantic-only plotting tests for CI stability; avoid golden-image tests
  unless absolutely necessary.
- Make legacy plotting writes default to temp/working dir and add a config flag to enforce a required allowlisted base paths with validation to prevent leakage of regulated data. 

**Verification checklist**
- Legacy plotting matches ADR-024/ADR-025 behaviors.
- New/updated tests cover `_plot_global` headless mode and save behavior.

---

## 5) ADR-018 docstrings for dynamic visualization classes

**Goal:** Close the remaining docstring gap for dynamically generated classes
used in plot plugin composition.

**Implementation steps**
1. **Document combined plot plugin classes.**
   - Add docstrings to `CombinedPlotPlugin` classes created in
     `src/calibrated_explanations/plugins/registry.py` (both trusted and
     untrusted paths) describing their purpose and methods.
   - If using `type()` or closures for dynamic class creation, set
     `__doc__` explicitly to satisfy pydocstyle.

2. **Verify docstring coverage.**
   - Run docstring linting (if available) or add tests ensuring
     dynamically generated classes have non-empty docstrings.

**Decisions**
- Introduce a named combined plugin wrapper class in `plugins/plots.py` to improve
  clarity and docstring linting.
- Update ADR-018 tracking artifacts (baseline docstring report) when the registry
  implementation changes.

**Verification checklist**
- Docstring linting passes for registry-generated classes.

---

## 6) Streaming-friendly explanation delivery (experimental)

**Goal:** Provide an opt-in streaming export for large explanation collections
without breaking existing APIs, and capture export telemetry.

**Implementation steps**
1. **Streaming API surface.**
   - Add a generator API in `src/calibrated_explanations/explanations/explanations.py`:
     - `to_json_stream(chunk_size=256, format="jsonl" | "chunked")` or
       `to_json(stream=True, chunk_size=...)`.
   - Stream by serializing explanations in chunks, yielding either JSON Lines
     or chunked JSON arrays (consistent with ADR-005 envelope format).

2. **Telemetry instrumentation.**
   - Add export telemetry fields: `export_rows`, `chunk_size`, `mode`,
     `peak_memory_mb`, `elapsed_seconds`, `schema_version`, `feature_branch`.
   - Store telemetry in the explanation collection metadata or in the
     explainer’s `_last_telemetry` record (via
     `src/calibrated_explanations/core/explain/orchestrator.py`).

3. **Memory profiling validation.**
   - Add a benchmark/test utility (e.g., under `scripts/`) to validate
     `10k rows < 200MB at chunk_size=256` and capture performance numbers.
   - Mark the feature experimental in `CHANGELOG.md` and update docs.

**Decisions**
- Support both JSON Lines and chunked JSON arrays for streaming; default to JSON
  Lines while exposing an explicit format parameter.
- Store minimal export telemetry in collection metadata and full telemetry in the
  explainer telemetry record to keep artifacts self-describing without bloating
  runtime stats.
- Replace `feature_branch` with explicit telemetry fields (e.g., `build_id` and
  `feature_flags`) for clarity and auditability.

**Verification checklist**
- Streaming exports yield valid JSON and preserve schema version.
- Telemetry fields are populated.
- Memory profile target documented with benchmark output.

---

## 7) Anti-pattern remediation Phase 2 (Category A)

**Goal:** Refactor tests that call private methods to use public APIs and remove
any dead private helpers uncovered during the refactor.

**Implementation steps**
1. **Inventory Category A calls.**
   - Add/extend a scan script (e.g., `scripts/scan_private_usage.py`) to
     enumerate private-member usage under `tests/` and group by symbol name.
   - Prioritize Category A calls (internal logic testing) for v0.10.1.

2. **Refactor tests to public APIs.**
   - Update tests to use `CalibratedExplainer` / `WrapCalibratedExplainer`
     public methods rather than direct private access.
   - If a test requires a private-only state, either expose a public factory
     (non-underscore) or update the test to reach the state via a supported
     workflow.

3. **Remove dead code.**
   - Delete private methods that are only referenced by tests (after verifying
     no runtime usage).
   - Add replacement tests that cover the same behavior through public APIs.

4. **Enforce and validate.**
   - Add a CI guard (lint/test step) to prevent new private-member usage in
     tests.

**Decisions**
- Use a targeted allowlist with explicit expiry dates for the CI guard during
  Category A remediation to prevent regressions without blocking unrelated work.
- Permit temporary waivers only when tracked with an explicit expiry aligned to a
  release gate.
- Rename Category B test helpers only when required to complete Category A
  refactors, avoiding scope creep.

**Verification checklist**
- Category A tests no longer call private members.
- Coverage remains unchanged or improves.

---

## 8) Open-source readiness workstream (v0.10.1 → v1.0.0-rc)

**Goal:** Track and land repository health, documentation, quality, community,
and licensing upgrades before the v1.0.0-rc freeze, starting in v0.10.1.

### 8.1 Repository structure & metadata

**Work items**
1. Add top-level community health files:
   - `CODE_OF_CONDUCT.md` (Contributor Covenant or equivalent).
   - `SECURITY.md` with supported versions and vulnerability disclosure steps.
   - `GOVERNANCE.md` or `MAINTAINERS.md` summarizing decision-making and
     stewardship expectations.
2. Link the new files from README and contributor docs for discoverability.

**Open questions**
- Should `GOVERNANCE.md` live at the repo root or under `.github/` for GitHub
  discovery, with a short root-level pointer?
- Do we want a dedicated `SUPPORT.md` or should support guidance remain in the
  README and issue templates?

**Decisions (minimal maintenance bias)**
- Place `GOVERNANCE.md` at the repo root with a short pointer file under
  `.github/` for GitHub discovery.
- Add a lightweight `SUPPORT.md` (3–5 bullets), link it from README.

**Verification checklist**
- GitHub community health checks show Code of Conduct and Security policy.
- README contains explicit links to the new files.

### 8.2 Documentation

**Work items**
1. Expand API reference beyond the explainer classes:
   - CLI entry points (`ce.plugins`) and usage.
   - Plugin registry contracts and trusted plugin metadata.
   - Serialization schema and envelope references.
   - Visualization/PlotSpec interfaces.
2. Add a README "Documentation map" linking:
   - API reference.
   - Architecture overview.
   - Contributor guidance.
   - Changelog and release notes.

**Open questions**
- Should CLI/plugin/serialization references live in a single API hub or remain
  split across dedicated pages?
- Is Sphinx autodoc sufficient for CLI and plugin registry docs, or should we
  keep hand-authored reference pages for those sections?

**Decisions (minimal maintenance bias)**
- Use a hybrid doc layout: a short API hub/index page linking to concise detail
  pages for CLI, plugins/registry, serialization, and viz.
- Hand-author CLI and registry reference sections; rely on autodoc for classes
  and other APIs to reduce drift.

**Verification checklist**
- API reference includes entries for CLI, plugins, serialization, and viz.
- README links to the new documentation map.

### 8.3 Quality & maintainability

**Work items**
1. Add dependency vulnerability scanning to CI:
   - Implement `pip-audit` or CodeQL workflow.
   - Ensure it runs on PRs and main.
2. Introduce a reproducible dependency constraints/lock workflow:
   - Decide on `pip-compile`, `uv` lockfiles, or a dedicated constraints file.
   - Update developer docs and CI install steps to use the lock/constraints.

**Open questions**
- Do we standardize on `pip-compile` (requirements/constraints) or adopt `uv`
  lockfiles for dev and CI?
- Should security scanning fail the build or run in warning mode until v1.0.0?

**Decisions (minimal maintenance bias)**
- Standardize on a single `pip-compile`-generated constraints file for dev/CI.
- Run dependency scanning as warn-on-PRs and fail-on-main after a short trial
  period; adjust based on noise.

**Verification checklist**
- CI runs dependency scanning and reports pass/fail.
- CI install steps reference the lock/constraints file.

### 8.4 Community & contribution

**Work items**
1. Add `ROADMAP.md` summarizing the release plan for contributors.
2. Link roadmap from README and CONTRIBUTING.
3. Update issue/PR templates to reference governance/security guidance.

**Open questions**
- Should roadmap be a high-level summary with links to `RELEASE_PLAN_v1.md`, or
  should we move the full plan into `ROADMAP.md` and keep the current file as
  an internal implementation plan?

**Decisions (minimal maintenance bias)**
- Keep `ROADMAP.md` as a high-level summary that links to the detailed plan in
  `RELEASE_PLAN_v1.md` and this implementation plan; avoid duplicating content.

**Verification checklist**
- Roadmap is present and linked from README and CONTRIBUTING.
- Templates reference new governance/security docs.

### 8.5 Licensing & governance

**Work items**
1. Add a contribution licensing statement:
   - DCO sign-off flow or inbound=outbound clause in CONTRIBUTING.
2. Clarify how contributions are licensed under BSD-3-Clause.

**Open questions**
- Are we adopting DCO (with `Signed-off-by`) or a simpler inbound=outbound
  clause only?
- Do we need a lightweight CLA for institutional contributors?

**Decisions (minimal maintenance bias)**
- Adopt DCO-only with `Signed-off-by` lines in commits/PRs; document the
  copy-paste sign-off in templates.
- Keep a lightweight institutional CLA template on hand but offer it only on
  request; do not require CLA by default.

**Verification checklist**
- CONTRIBUTING explains contribution licensing expectations.
- README or GOVERNANCE references the contribution licensing model.

---


## Release gate alignment

The following release gates map directly to this plan:
- **Envelope + schema**: validated round-trips and fixtures updated.
- **PlotSpec + plugin registry**: PlotSpec validation, registry completeness,
  and legacy plugin fallback verified.
- **Legacy plotting**: ADR-024/ADR-025 behaviors enforced with tests.
- **Docs**: schema, plot plugin, and streaming docs updated.
