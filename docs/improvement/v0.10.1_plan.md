# v0.10.1 Release Task Implementation Plan

This plan expands the v0.10.1 tasks from `docs/improvement/RELEASE_PLAN_v1.md` with
implementation details grounded in ADRs, engineering standards, and current code layout. Each section
lists the concrete work items, impacted modules, verification steps, and open
questions needed to satisfy the release gate.

## Source references reviewed

- Release task list: `docs/improvement/RELEASE_PLAN_v1.md` (v0.10.1 section + ADR status appendix).
-- ADRs: `docs/improvement/adrs/ADR-005-explanation-json-schema-versioning.md`,
  `ADR-007-visualization-abstraction-layer.md`, `ADR-014-plot-plugin-strategy.md`,
  `ADR-016-plot-spec-separation.md`, `docs/standards/STD-018-code-documentation-standard.md`,
  `ADR-006-plugin-registry-trust-model.md`, `ADR-010-core-vs-evaluation-split-and-distribution.md`, `ADR-012-documentation-and-gallery-build-policy.md`.
- PlotSpec docs: `docs/improvement/plot_spec/PLOTSPEC_SCHEMA.md`,
  `docs/improvement/plot_spec/PRIMITIVES_SCHEMA.md`.
- Anti-pattern remediation: `docs/improvement/ANTI_PATTERN_REMEDIATION_PLAN.md`.
- Code/documentation uplift guide: `docs/improvement/code_documentation_uplift.md`.

---

## 1) ADR-005 Explanation payload schema contract

**Goal:** Confirm the v1.0.0 payload schema as the canonical JSON contract and
ship a validation + fixture/doc refresh aligned to the existing serializer.

**Key ADR gaps to close (from ADR-005 appendix):**
- Docs and fixtures still describe legacy shapes instead of the v1 payload.
- `validate_payload` only checks JSON Schema; semantic invariants rely on serializers.
- Schema version is recommended but not consistently documented.

**Implementation steps**
1. **Confirm the payload schema as the v1 contract.**
   - Keep `src/calibrated_explanations/schemas/explanation_schema_v1.json` as the
     authoritative schema for instance-level explanations.
   - Document `provenance` and `metadata` as optional extension points for runtime
     context without enforcing a dedicated envelope.

2. **Align validation helpers to payload semantics.**
   - Ensure `calibrated_explanations.schema.validate_payload` remains focused on the
     payload schema with optional `jsonschema`.
   - Keep serialization-time interval invariants (`low <= predict <= high`) as the
     semantic checks.

3. **Update docs + fixtures.**
   - Update `docs/schema_v1.md` to reflect the payload fields and recommended
     `schema_version` usage.
   - Refresh fixtures/tests that still document or assume the legacy schema shape.

**Decisions**
- Preserve the payload-only contract for v1.0.0; defer envelopes and type registries.
- Keep `schema_version` recommended but not required for v1 payloads.
- Treat `provenance` and `metadata` as the stable extension surface for optional
  runtime context.

**Open questions**
- Should v2 make `schema_version` required and enforce semver at validation time?
- Do we want to formalize a minimal set of `provenance` keys once external consumers
  stabilize?

**Verification checklist**
- Payload fixtures validate via `jsonschema`.
- Round-trip tests pass for payload-only serialization.
- Interval invariants are enforced during serialization.

---

## 2) ADR-007 + ADR-016 PlotSpec schema/registry/round-trip

**Goal:** Finalize PlotSpec schema metadata, registries, validation, and
headless export support, aligning with ADR-007/ADR-016 gaps.

**Key ADR gaps to close**
- `PlotSpec` missing `kind`/`mode`/`feature_order`/`version` fields and
  `save_behavior` metadata.
- Validation is bar-only and builders skip validation.
- JSON round-trip inconsistent for triangular/global specs.
- No headless export support and no plot kind registry.

**Implementation steps**
1. **Extend PlotSpec dataclasses.**
   - Update `src/calibrated_explanations/viz/plotspec.py` with:
     - required fields: `kind`, `mode`, `feature_order`.
     - version field (PlotSpec schema version distinct from explanation schema).
     - `save_behavior` structure (`path`, `title`, `default_exts`).
   - Add a `PlotKindRegistry` (new module or part of
     `viz/serializers.py`) for supported kinds and versioned validation.

2. **Update serialization and validation.**
   - Extend `src/calibrated_explanations/viz/serializers.py` to round-trip new
     fields and enforce `kind`-aware validation (different requirements per
     `factual_probabilistic`, `alternative_probabilistic`, `triangular`,
     `global_*`, etc.).
   - Adjust `validate_plotspec` to accept non-panel dict payloads for
     triangular/global plots while still validating required metadata fields.

3. **Ensure builders call validation and preserve feature order.**
   - Update `src/calibrated_explanations/viz/builders.py` to:
     - call `validate_plotspec` before returning payloads.
     - preserve `feature_order` from callers instead of renumbering.
     - set `mode`, `kind`, and `save_behavior` consistently.

4. **Add headless export support.**
   - Extend `src/calibrated_explanations/viz/matplotlib_adapter.py` to allow
     rendering directly to bytes (e.g., PNG/SVG) when `show=False` and
     `save_behavior` requests a headless export.
   - Add tests to verify byte outputs for PlotSpec rendering.

**Decisions**
- Migrate triangular/global PlotSpec payloads to dedicated dataclasses in v0.10.1.
- Store PlotSpec schema version as an explicit dataclass field (serialized in JSON).
- Add a separate JSON schema file for PlotSpec in v0.10.1 to align with explanation
  schema validation.
- Make PlotSpec include optional provenance fields (data_slice_id, rendering_seed) for reproducible audits.

**Verification checklist**
- JSON round-trips for bar, triangular, and global PlotSpecs are stable.
- Builders call validation in tests.
- Headless export returns bytes and honors `save_behavior`.

---

## 3) ADR-014 Visualization plugin architecture completion

**Goal:** Restore the full plot plugin architecture: functional legacy fallback,
helper base classes, metadata alignment, override resolution, validation hooks,
CLI tooling, and docs.

**Key ADR gaps to close**
- Legacy fallback plugin inert, no base classes, missing default renderer.
- Renderer override resolution ignores env/kwargs.
- Missing `PlotPluginError`, validation hooks, CLI helpers, and docs.

**Implementation steps**
1. **Finalize plugin API + helpers.**
   - Add helper base classes to `src/calibrated_explanations/viz/plugins.py`
     (e.g., `BasePlotBuilder`, `BasePlotRenderer`) with lifecycle hooks and
     `validate_plotspec` integration.
   - Introduce a `PlotPluginError` in `src/calibrated_explanations/utils/exceptions.py`.

2. **Ensure a working legacy fallback plugin.**
   - Register a legacy builder/renderer pair in `src/calibrated_explanations/plugins/builtins.py`
     that delegates to `legacy.plotting` with `show/path/save_ext` semantics.
   - Ensure the default style in the registry resolves to legacy when no
     overrides are configured.

3. **Align metadata and resolution order.**
   - Extend plot plugin metadata to include `default_renderer` (update
     `validate_plot_builder_metadata` in `src/calibrated_explanations/plugins/registry.py`).
   - Update `src/calibrated_explanations/plotting.py` to honor:
     - explicit `renderer`/`style` kwargs,
     - environment overrides (`CE_PLOT_RENDERER`, `CE_PLOT_STYLE`),
     - pyproject configuration in `[tool.calibrated_explanations.plots]`.

4. **CLI tooling + documentation.**
   - Add CLI commands in `src/calibrated_explanations/plugins/cli.py`:
     - `ce.plugins list --plots` (verify output),
     - `ce.plugins validate-plot --builder <id>`,
     - `ce.plugins set-default --plot-style <id>`.
   - Add a “Writing plot plugins” guide in `docs/plugins.md` or a new
     contributor doc with examples and migration notes.

**Decisions**
- Place plot plugin base classes in `plugins/` with visualization adapters in `viz/`
  to preserve a clear plugin boundary.
- Keep existing plot plugin IDs stable and add versioning via metadata fields.
- Surface `PlotPluginError` directly for invalid plugin usage to provide explicit,
  auditable failures in `.plot()` workflows.

**Verification checklist**
- `.plot()` resolves legacy fallback when no plugin configured.
- Override paths and fallbacks work in tests.
- CLI commands return expected output and error messages.

---

## 4) Legacy plotting maintenance (ADR-024/ADR-025 superseded)

**Goal:** Maintain legacy plotting reference and ensure any remaining legacy issues are addressed via the maintenance reference, as ADR-024 and ADR-025 have been deprecated and superseded by `docs/maintenance/legacy-plotting-reference.md`.

**Implementation steps**
1. **Update maintenance reference.** Ensure `docs/maintenance/legacy-plotting-reference.md` captures all legacy plotting details for maintainers.
2. **Retire ADR gaps.** Since ADRs are superseded, no new implementation for the listed gaps; legacy code remains the source of truth.
3. **Test legacy paths.** Continue testing legacy plotting to prevent regressions, but do not enforce new contracts beyond what's in the code.

**Decisions**
- Legacy plotting contracts and semantics are now documented in the maintenance reference only.
- No changes to enforce ADR-024/ADR-025 requirements; focus on stability.

**Verification checklist**
- Maintenance reference is up-to-date.
- Legacy plotting tests pass without new assertions from deprecated ADRs.

---

## 5) Standard-018 docstrings for dynamic visualization classes

**Goal:** Close the remaining docstring gap for dynamically generated classes
used in plot plugin composition.

**Implementation steps**
1. **Document combined plot plugin classes.**
   - Add docstrings to `CombinedPlotPlugin` classes created in
     `src/calibrated_explanations/plugins/registry.py` (both trusted and
     untrusted paths) describing their purpose and methods.
   - If using `type()` or closures for dynamic class creation, set
     `__doc__` explicitly to satisfy pydocstyle.

2. **Verify docstring coverage.**
   - Run docstring linting (if available) or add tests ensuring
     dynamically generated classes have non-empty docstrings.

**Decisions**
- Introduce a named combined plugin wrapper class in `plugins/plots.py` to improve
  clarity and docstring linting.
- Update Standard-018 tracking artifacts (baseline docstring report) when the registry
  implementation changes.

**Verification checklist**
- Docstring linting passes for registry-generated classes.

---

## 6) Streaming-friendly explanation delivery (experimental)

**Goal:** Provide an opt-in streaming export for large explanation collections
without breaking existing APIs, and capture export telemetry.

**Implementation steps**
1. **Streaming API surface.**
   - Add a generator API in `src/calibrated_explanations/explanations/explanations.py`:
     - `to_json_stream(chunk_size=256, format="jsonl" | "chunked")` or
       `to_json(stream=True, chunk_size=...)`.
   - Stream by serializing explanations in chunks, yielding either JSON Lines
     or chunked JSON arrays (consistent with ADR-005 envelope format).

2. **Telemetry instrumentation.**
   - Add export telemetry fields: `export_rows`, `chunk_size`, `mode`,
     `peak_memory_mb`, `elapsed_seconds`, `schema_version`, `feature_branch`.
   - Store telemetry in the explanation collection metadata or in the
     explainer’s `_last_telemetry` record (via
     `src/calibrated_explanations/core/explain/orchestrator.py`).

3. **Memory profiling validation.**
   - Add a benchmark/test utility (e.g., under `scripts/`) to validate
     `10k rows < 200MB at chunk_size=256` and capture performance numbers.
   - Mark the feature experimental in `CHANGELOG.md` and update docs.

**Decisions**
- Support both JSON Lines and chunked JSON arrays for streaming; default to JSON
  Lines while exposing an explicit format parameter.
- Store minimal export telemetry in collection metadata and full telemetry in the
  explainer telemetry record to keep artifacts self-describing without bloating
  runtime stats.
- Replace `feature_branch` with explicit telemetry fields (e.g., `build_id` and
  `feature_flags`) for clarity and auditability.

**Verification checklist**
- Streaming exports yield valid JSON and preserve schema version.
- Telemetry fields are populated.
- Memory profile target documented with benchmark output.

---

## 7) Anti-pattern remediation Phase 2 (Pattern 2 & 3)

**Goal:** Remediate Pattern 2 (Test Utilities) and Pattern 3 (Dead Code) before
addressing Category A (Internal Logic) to reduce noise and simplify the codebase.

**Implementation steps**
1. **Inventory Pattern 2 & 3 candidates.**
   - Use `scripts/anti-pattern-analysis/analyze_private_methods.py` to generate a fresh report.
   - Identify "Pattern 3 (Completely Dead)" and "Pattern 3/2 (Only Tests)" for removal.
   - Identify "Pattern 2 (Shared Test Utility)" for renaming/moving.

2. **Remediate Pattern 3 (Dead Code).**
   - Remove library private methods that are completely unused or only used by
     tests (after verifying no runtime usage).
   - Delete associated tests if they only test the removed private method.

3. **Remediate Pattern 2 (Test Utilities).**
   - Rename test helpers (remove leading `_`) and move them to `tests/helpers/`
     if shared across multiple test files.
   - Update all call sites in tests.

4. **Inventory Category A calls.**
   - Enumerate remaining private-member usage under `tests/` (Pattern 1).

5. **Refactor tests to public APIs (Category A).**
   - Update tests to use `CalibratedExplainer` / `WrapCalibratedExplainer`
     public methods rather than direct private access.

6. **Enforce and validate.**
   - Update `.github/private_member_allowlist.json`.
   - Add a CI guard to prevent new private-member usage in tests.

**Decisions**
- Use a targeted allowlist with explicit expiry dates for the CI guard during
  Category A remediation to prevent regressions without blocking unrelated work.
- Permit temporary waivers only when tracked with an explicit expiry aligned to a
  release gate.
- Rename Category B test helpers only when required to complete Category A
  refactors, avoiding scope creep.

**Verification checklist**
- Category A tests no longer call private members.
- Coverage remains unchanged or improves.

---

## 8) Open-source readiness workstream (v0.10.1 → v1.0.0-rc)

**Goal:** Track and land repository health, documentation, quality, community,
and licensing upgrades before the v1.0.0-rc freeze, starting in v0.10.1.

### 8.1 Repository structure & metadata

**Work items**
1. Add top-level community health files:
   - `CODE_OF_CONDUCT.md` (Contributor Covenant or equivalent).
   - `SECURITY.md` with supported versions and vulnerability disclosure steps.
   - `GOVERNANCE.md` or `MAINTAINERS.md` summarizing decision-making and
     stewardship expectations.
2. Link the new files from README and contributor docs for discoverability.

**Open questions**
- Should `GOVERNANCE.md` live at the repo root or under `.github/` for GitHub
  discovery, with a short root-level pointer?
- Do we want a dedicated `SUPPORT.md` or should support guidance remain in the
  README and issue templates?

**Decisions (minimal maintenance bias)**
- Place `GOVERNANCE.md` at the repo root with a short pointer file under
  `.github/` for GitHub discovery.
- Add a lightweight `SUPPORT.md` (3–5 bullets), link it from README.

**Verification checklist**
- GitHub community health checks show Code of Conduct and Security policy.
- README contains explicit links to the new files.

### 8.2 Documentation

**Work items**
1. Expand API reference beyond the explainer classes:
   - CLI entry points (`ce.plugins`) and usage.
   - Plugin registry contracts and trusted plugin metadata.
   - Serialization schema and envelope references.
   - Visualization/PlotSpec interfaces.
2. Add a README "Documentation map" linking:
   - API reference.
   - Architecture overview.
   - Contributor guidance.
   - Changelog and release notes.

**Open questions**
- Should CLI/plugin/serialization references live in a single API hub or remain
  split across dedicated pages?
- Is Sphinx autodoc sufficient for CLI and plugin registry docs, or should we
  keep hand-authored reference pages for those sections?

**Decisions (minimal maintenance bias)**
- Use a hybrid doc layout: a short API hub/index page linking to concise detail
  pages for CLI, plugins/registry, serialization, and viz.
- Hand-author CLI and registry reference sections; rely on autodoc for classes
  and other APIs to reduce drift.

**Verification checklist**
- API reference includes entries for CLI, plugins, serialization, and viz.
- README links to the new documentation map.

### 8.3 Quality & maintainability

**Work items**
1. Add dependency vulnerability scanning to CI:
   - Implement `pip-audit` or CodeQL workflow.
   - Ensure it runs on PRs and main.
2. Introduce a reproducible dependency constraints/lock workflow:
   - Decide on `pip-compile`, `uv` lockfiles, or a dedicated constraints file.
   - Update developer docs and CI install steps to use the lock/constraints.

**Open questions**
- Do we standardize on `pip-compile` (requirements/constraints) or adopt `uv`
  lockfiles for dev and CI?
- Should security scanning fail the build or run in warning mode until v1.0.0?

**Decisions (minimal maintenance bias)**
- Standardize on a single `pip-compile`-generated constraints file for dev/CI.
- Run dependency scanning as warn-on-PRs and fail-on-main after a short trial
  period; adjust based on noise.

**Verification checklist**
- CI runs dependency scanning and reports pass/fail.
- CI install steps reference the lock/constraints file.

### 8.4 Community & contribution

**Work items**
1. Add `ROADMAP.md` summarizing the release plan for contributors.
2. Link roadmap from README and CONTRIBUTING.
3. Update issue/PR templates to reference governance/security guidance.

**Open questions**
- Should roadmap be a high-level summary with links to `RELEASE_PLAN_v1.md`, or
  should we move the full plan into `ROADMAP.md` and keep the current file as
  an internal implementation plan?

**Decisions (minimal maintenance bias)**
- Keep `ROADMAP.md` as a high-level summary that links to the detailed plan in
  `RELEASE_PLAN_v1.md` and this implementation plan; avoid duplicating content.

**Verification checklist**
- Roadmap is present and linked from README and CONTRIBUTING.
- Templates reference new governance/security docs.

### 8.5 Licensing & governance

**Work items**
1. Add a contribution licensing statement:
   - DCO sign-off flow or inbound=outbound clause in CONTRIBUTING.
2. Clarify how contributions are licensed under BSD-3-Clause.

**Open questions**
- Are we adopting DCO (with `Signed-off-by`) or a simpler inbound=outbound
  clause only?
- Do we need a lightweight CLA for institutional contributors?

**Decisions (minimal maintenance bias)**
- Adopt DCO-only with `Signed-off-by` lines in commits/PRs; document the
  copy-paste sign-off in templates.
- Keep a lightweight institutional CLA template on hand but offer it only on
  request; do not require CLA by default.

**Verification checklist**
- CONTRIBUTING explains contribution licensing expectations.
- README or GOVERNANCE references the contribution licensing model.

---


## Release gate alignment

The following release gates map directly to this plan:
- **Envelope + schema**: validated round-trips and fixtures updated.
- **PlotSpec + plugin registry**: PlotSpec validation, registry completeness,
  and legacy plugin fallback verified.
- **Legacy plotting**: ADR-024/ADR-025 behaviors enforced with tests.
- **Docs**: schema, plot plugin, and streaming docs updated.
